---
title: "Google Earth Engine"
---

## Summary

This week we introduced the Google Earth Engine (GEE), which is a geographical processing service and permits geospatial analysis at scale. Much more powerful than SNAP, isn't it? The basic concepts and functions of GEE will be demonstrated in this section.

### The Set Up of GEE

#### Client side vs. Server side

One of GEE's biggest advantages lies in its massive server side computational power and cloud-hosted data catalog, which allow users to perform planetary-scale geospatial analysis within seconds without downloading any data. However, the strict separation between the client side environment and server side objects also introduces a steep learning curve, such as the necessity of using `.map()` instead of traditional for loops for image collections.

#### Scale

Unlike traditional GIS software, GEE's resolution is dynamically determined by the output rather than the input. During analysis, GEE aggregates images to fit a 256x256 grid. It selects the image pyramid level closest to the specified scale and resamples the data, utilizing nearest neighbor by default. This output-driven mechanism ensures fast processing and visualization for planetary-scale datasets.

::: {.callout-tip appearance="simple" icon="false"}
An interesting observation from the scale example is that querying a pixel at a 10m scale yields the exact same value as the 30m scale. This occurs because GEE cannot exceed **the sensor's native resolution** (e.g. 30m for Landsat 8). Instead, it simply duplicates the base pixel using default nearest neighbor resampling.
:::

### Functions

#### Filter

Images (raster data) could be filtered by date/location (specified path and row)/boundary/polygon. Features (geometries with attributes) can also be filtered by specific attributes.

For example:

``` javascript
// filter by attributes (Delhi in India)
var Delhi = ee.FeatureCollection('users/path/india')
  .filter('GID_1 == "IND.25_1"');
```

#### 
